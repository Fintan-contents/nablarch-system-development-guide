# 単体テストの考え方(Web)

これまでNablarchで提示されてきたテスト手法は品質偏重であり、多くのプロジェクトにとっては重厚長大なプロセスになっていました。
高いカバレッジを実現できる一方で、特にテストデータ作成、維持する労力が掛かっていました。

本プロジェクトでは、コストと品質のバランスを重視したテスト手法を実施することとします。
- 最も労力が掛かっていたテストデータ作成、維持を行わなくてよいようにします
- かといって「全て手動でテストする」という極端に走らず、テストコードを書いたほうが効率的な箇所は積極的にテストコードを書きます

テストデータの作成、維持において特に労力が掛かっていたのがデータベースに関するものでした。
テーブル名やカラム名の変更は、多くのテストデータに影響をしてしまうためです。
また、データベースアクセスを含むテストは、スローテストの要因にもなっていました。

これらの問題に対応するため、本プロジェクト(Webアプリケーション)ではリクエスト単体テストを使用をしません。
ただし、単純に今までやっていたことをやめるだけでは、品質の低下が懸念されるため、別のテストや机上確認で補えるよう配慮します。
本プロジェクトでは製造・単体テスト工程までに以下の品質確認を行います。

- 机上確認
- クラス単体テスト
- 取引単体テスト


開発者が作成する成果物とそのテスト方法を記載します。

| 成果物         | 机上 | クラス | 取引 |
|----------------|------|--------|------|
| Action         | -    | -      | o    |
| Form           | o    | o      | o    |
| ドメインクラス | o    | -      | o    |
| Service        | -    | o      | o    |
| SQLファイル    | o    | -      | o    |
| Entity         | -    | -      | o    |
| DTO            | -    | -      | o    |
| JSP            | -    | -      | o    |
| routes.xml     | -    | -      | o    |


## Action

Actionクラスでは、取引単体テストにて手動で動作確認します。

従来、リクエスト単体テストでActionのテストを行っていましたが、
業務ロジック以外では取引単体テストで確認できるため、手動で確認するようにします。
- バリデーション制御(エラーが表示されることで確認可能)
- サービスの呼び出し(画面表示やDBなどの処理結果で確認可能)
- リクエストスコープ、セッションスコープへの値設定(画面表示で確認可能)
- フォワード(画面表示で確認可能)

業務ロジックについては、後述するServiceクラスで実現するため、
Actionには業務ロジックは含まれません。

## Form

### Formのアノテーション確認

Formのフィールドに、設計書に記載された通りのアノテーションが付与されていることを確認します。
（必須アノテーションおよびドメインアノテーション）
設計書とFormのソースコードを見比べて、目視で確認を行います。


アノテーションの付与は宣言的なものであり、テストコードを書く方法では効率良くバグを見つけることができません。
例えば、テストを書く場合、以下のような手順になります。

- Formの必須項目にnullを設定します
- バリデーションを実行します
- 必須エラーが発生することを確認します

しかし、このようなコードを書く時、設計書を見てその項目が必須であることを読み取って、上記のようなコードを書くはずです。
であれば、設計書とFormのソースコードを見比べて、正しいアノテーションが付与されていることを確認するという方法でも
実質的にやっていることは同じであり、かつ、遥かに効率よく確認ができます。

アノテーションを付与する場合、具体的なロジックや値（最大値、最小値等）は含まれていないため、
プログラミングの段階ではスペルミス以外のミスが混入することはありません。
（スペルミスはコンパイラやツールでチェックできるのでテストは不要）


### バリデーションロジックの確認

必須アノテーションやドメインアノテーション以外で、`@AssertTrue`等を使ってバリデーションロジックを書いている場合、
クラス単体テストの対象とします。

## ドメインクラス

ドメイン定義を保持するクラスであり、ドメイン定義設計書を元に作成します。

ドメイン定義設計書からドメインクラスを作成する際に、間違った定義をしてしまう可能性はあります(例えば、最大桁の写し間違い)。
しかし、限界値分析によるテストコードを書いてその誤りを検知することは非効率であるため、
机上レビューによる確認を行います。


## Service

Serviceでは、いわゆる業務ロジックを記述します。
HttpRequestやExecutionContextなどNablarchのAPIは使わないようにします。

データベースアクセスにはユニバーサルDaoを使いますが、UniversalDaoクラスを使用するのではなく、
DaoContextインタフェースを使用（依存）するようにします。
staticメソッドを持つクラスUniversalDaoではなく、インタフェースDaoContextに対して依存するため、
データベースアクセスをスタブ化することが容易になります。


``` java
public class MyService {

    private final DaoContext universalDao;
     
    public MyService() {
        this(DaoFactory.create());
    }
    /** テスト用コンストラクタ */
    MyService(DaoContext universalDao) {
        this.universalDa = universalDao;
    }
}
```

``` java
DaoContext stub = new DaoContextStub() {
    @Override
    public T findByPk(int id) {
        return (T) new Foo("ふー");
    }
}
```

UniversalDaoの振る舞いをテストケース毎に変更する方法として、モックライブラリを使用するという手段も考えられたが
本プロジェクトでは以下の理由によりモックライブラリの採用を見送りました。

- 想定した動作をしない場合のトラブルシューティングが難しいです(特にアーキテクト離任後の保守フェーズ)
- バージョンアップにより後方互換性が崩れる場合があります(ex: JMockit)


## SQLファイル

設計工程でSQLを検討する必要があるが、机上でSQLを設計してしまうと品質が十分確保できないという問題があります。
このため、設計時点でSQLを試行しながら設計を行うこととし、SQLファイルも同時に作成します。
（このSQLファイルは製造工程へのインプットとなります）

SQLを試行できるよう、SQL Executorを使用します。


## Entity

GSPプラグインで自動生成するため、クラス単体テスト対象外とします。

## DTO

ロジックを含まず、かつアクセサはIDEで自動生成するため、クラス単体テスト対象外とします。

## JSP

従来どおり、取引単体テストで確認します。


## routes.xml

ルーティングのミスは、手動でテストしたときに容易に発見できるので、取引単体テストで確認します。

