# 単体テストの考え方(Web)

これまでNablarchで提示されてきたテスト手法は品質偏重であり、多くのプロジェクトにとっては重厚長大なプロセスになっていました。
高いカバレッジを実現できる一方で、特にテストデータ作成、維持する労力が掛かっていました。

本プロジェクトでは、コストと品質のバランスを重視したテスト手法を実施することとします。
- 最も労力が掛かっていたテストデータ作成、維持を行わなくてよいようにします
- かといって「全て手動でテストする」という極端に走らず、テストコードを書いたほうが効率的な箇所は積極的にテストコードを書きます

テストデータの作成、維持において特に労力が掛かっていたのがデータベースに関するものでした。
テーブル名やカラム名の変更は、多くのテストデータに影響をしてしまうためです。
また、データベースアクセスを含むテストは、スローテストの要因にもなっていました。

これらの問題に対応するため、本プロジェクト(Webアプリケーション)ではリクエスト単体テストを使用をしません。
ただし、単純に今までやっていたことをやめるだけでは、品質の低下が懸念されるため、別のテストや机上確認で補えるよう配慮します。
本プロジェクトでは製造・単体テスト工程までに以下の品質確認を行います。

- 机上確認
- クラス単体テスト
- 取引単体テスト

## 成果物ごとの確認方法
開発者が作成する成果物とそのテスト方法を記載します。

| 成果物         | 机上 | クラス | 取引 |
|----------------|------|--------|------|
| Action         | -    | -      | o    |
| Form           | o    | o      | o    |
| ドメインクラス | o    | -      | o    |
| Service        | -    | o      | o    |
| SQLファイル    | o    | -      | o    |
| Entity         | -    | -      | o    |
| DTO            | -    | -      | o    |
| JSP            | -    | -      | o    |
| routes.xml     | -    | -      | o    |


### Action

Actionクラスでは、取引単体テストにて手動で動作確認します。

従来、リクエスト単体テストでActionのテストを行っていましたが、
業務ロジック以外では取引単体テストで確認できるため、手動で確認するようにします。
- バリデーション制御(エラーが表示されることで確認可能)
- サービスの呼び出し(画面表示やDBなどの処理結果で確認可能)
- リクエストスコープ、セッションスコープへの値設定(画面表示で確認可能)
- フォワード(画面表示で確認可能)

業務ロジックについては、後述するServiceクラスで実現するため、
Actionには業務ロジックは含まれません。

### Form

#### Formのアノテーション確認

Formのフィールドに、設計書に記載された通りのアノテーションが付与されていることを確認します。
（必須アノテーションおよびドメインアノテーション）
設計書とFormのソースコードを見比べて、目視で確認を行います。


アノテーションの付与は宣言的なものであり、テストコードを書く方法では効率良くバグを見つけることができません。
例えば、テストを書く場合、以下のような手順になります。

- Formの必須項目にnullを設定します
- バリデーションを実行します
- 必須エラーが発生することを確認します

しかし、このようなコードを書く時、設計書を見てその項目が必須であることを読み取って、上記のようなコードを書くはずです。
であれば、設計書とFormのソースコードを見比べて、正しいアノテーションが付与されていることを確認するという方法でも
実質的にやっていることは同じであり、かつ、遥かに効率よく確認ができます。

アノテーションを付与する場合、具体的なロジックや値（最大値、最小値等）は含まれていないため、
プログラミングの段階ではスペルミス以外のミスが混入することはありません。
（スペルミスはコンパイラやツールでチェックできるのでテストは不要）


#### バリデーションロジックの確認

必須アノテーションやドメインアノテーション以外で、`@AssertTrue`等を使ってバリデーションロジックを書いている場合、
クラス単体テストの対象とします。

### ドメインクラス

ドメイン定義を保持するクラスであり、ドメイン定義設計書を元に作成します。

ドメイン定義設計書からドメインクラスを作成する際に、間違った定義をしてしまう可能性はあります(例えば、最大桁の写し間違い)。
しかし、限界値分析によるテストコードを書いてその誤りを検知することは非効率であるため、
机上レビューによる確認を行います。


### Service

Serviceでは、いわゆる業務ロジックを記述します。
HttpRequestやExecutionContextなどNablarchのAPIは使わないようにします。

データベースアクセスにはユニバーサルDaoを使いますが、UniversalDaoクラスを使用するのではなく、
DaoContextインタフェースを使用（依存）するようにします。
staticメソッドを持つクラスUniversalDaoではなく、インタフェースDaoContextに対して依存するため、
データベースアクセスをスタブ化することが容易になります。


``` java
public class MyService {

    private final DaoContext universalDao;
     
    public MyService() {
        this(DaoFactory.create());
    }
    /** テスト用コンストラクタ */
    MyService(DaoContext universalDao) {
        this.universalDa = universalDao;
    }
}
```

``` java
DaoContext stub = new DaoContextStub() {
    @Override
    public T findByPk(int id) {
        return (T) new Foo("ふー");
    }
}
```

UniversalDaoの振る舞いをテストケース毎に変更する方法として、モックライブラリを使用するという手段も考えられましたが、
本プロジェクトでは以下の理由によりモックライブラリの採用を見送りました。

- 想定した動作をしない場合のトラブルシューティングが難しいです(特にアーキテクト離任後の保守フェーズ)
- バージョンアップにより後方互換性が崩れる場合があります(ex: JMockit)


### SQLファイル

設計工程でSQLを検討する必要があるが、机上でSQLを設計してしまうと品質が十分確保できないという問題があります。
このため、設計時点でSQLを試行しながら設計を行うこととし、SQLファイルも同時に作成します。
（このSQLファイルはPGUT工程へのインプットとなります）

SQLを試行できるよう、SQL Executorを使用します。


### Entity

GSPプラグインで自動生成するため、クラス単体テスト対象外とします。

### DTO

ロジックを含まず、かつアクセサはIDEで自動生成するため、クラス単体テスト対象外とします。

### JSP

従来どおり、取引単体テストで確認します。


### routes.xml

ルーティングのミスは、手動でテストしたときに容易に発見できるので、取引単体テストで確認します。


## 取引単体テストの回帰テスト
取引単体テストは、回帰テストの負担を軽減するため初回のみ打鍵で行い、二回目以降は自動テストツールを使って自動化します。

以下で、手順の概要を説明します。

### 1. 初回の打鍵テスト
#### 1-1. ブラウザ操作とエビデンスを記録する
![打鍵テストを記録する](regression-test-overview-001.jpg)

まず、初回は打鍵でテストを行います。

このとき、Apache JMeterのHTTP(S) Test Script Recorderという機能を利用してブラウザで行った操作を記録しておきます。  
操作記録はJMeterのテスト計画ファイルであるjmxファイルとして保存されます。

また、このとき画面のハードコピーやデータベースのダンプなどのエビデンスも手動で記録しておきます。

#### 1-2. レスポンスを記録する
![レスポンスを記録する](regression-test-overview-002.jpg)

記録したjmxファイルを実行し、レスポンスファイル（HTML,CSS,JavaScript）を記録します。

### 2. 二回目以降の自動テスト
![自動テスト](regression-test-overview-003.jpg)

二回目以降の回帰テストでは、取引単体テストを自動実行するツールを使用します。

初回の打鍵テストで記録したjmxファイルやエビデンス、レスポンスファイルを自動テストツールの所定のディレクトリに配置することで、取引単体テストを自動実行できます。

これにより、取引単体テストの回帰テストのコストを抑えることができます。

### 詳細な情報
テスト方法やエビデンスの取得方法、自動テストツールの詳細な説明については、下記リンクを参照してください。

- [エビデンスの取得方法（ログとDBダンプ）](エビデンスの取得方法（ログとDBダンプ）.md)
    - データベースダンプの取得方法
- [エビデンスの取得方法（画面）]( エビデンスの取得方法（画面）.md)
    - 画面ハードコピーの取得方法
    - JMeterでブラウザ操作を記録する方法
- `/サンプルプロジェクト/設計書/A1_プロジェクト管理システム/020_方式設計/020_開発標準/020_テスト標準/単体テスト標準.xlsx`
    - 取得したエビデンスの格納方法について
- [取引単体テストのテスト方法（Web）](取引単体テストのテスト方法（Web）.md)
    - 排他制御エラーのテストなど、具体的な実施方法について
- [取引単体テストの自動実行方法（Web）](取引単体テストの自動実行方法（Web）.md)
    - 自動テストツールをサンプルで動かす方法
- [自動テストツールのREADME](../../../ソースコード/proman-project/proman-jmeter/README.md)
    - 自動テストツールの詳細な説明
