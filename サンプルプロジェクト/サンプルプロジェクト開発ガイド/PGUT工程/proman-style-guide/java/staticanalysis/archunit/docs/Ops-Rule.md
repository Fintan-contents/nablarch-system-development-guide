# ArchUnit運用ガイド

実際のプロジェクトでArchUnitを運用していく際のガイドです。

ここでは、アーキテクチャ「違反」という言葉を「ArchUnitを利用してテストしているアーキテクチャルールに違反している」という意味で使用します。

## 基本的な考え方

### 原則1: アーキテクチャ違反は全て解決します

プロジェクトで決めたアーキテクチャに違反したコードはバグを生む温床となったり、改修時の思わぬ影響範囲拡大を招きます。  
アーキテクチャに違反した場合、自動テストが失敗します。テストの失敗を放置するとアーキテクチャ違反だけではなく、ロジックの問題まで見逃すことになりソースコードの品質を保つことができません。必ずテストが全件成功する状態を維持してください。

### 原則2: アーキテクチャ違反を解消するために品質を下げてはいけません

開発者はアーキテクチャ違反を見つけたら対応をしなければなりませんが、 その際違反を回避するための修正をしたことによって、かえってソースコード品質を落とすようなことがあってはいけません。

このような場合は、有識者やプロジェクトのアーキテクトに相談して 適切な対処を仰ぐようにしましょう。

### 原則3: 正当な理由があってアーキテクチャ違反となる場合、チェック対象から外します

正当な理由がある場合は、アーキテクチャ違反となっているソースコードをチェック対象から除外するようにします。

プロジェクトのアーキテクトは開発者からの申請を受けて妥当であると判断した場合、
該当箇所をチェック対象から除外するようにしてください。

この運用をすることによって、違反が放置されたり、開発者が無理に違反を回避したりすることを防げます。

## テスト実行時の注意

### テスト対象のクラスについて

ArchUnitではクラスパス・モジュールパスに含まれるクラスからパッケージなどにより、絞り込みを行うことが可能です。

当たり前のことですが、クラスパス・モジュールパスに含まれないクラスについてはテストすることができません。

バッチやWebアプリのように処理方式毎にモジュールを分けている場合がこれに当てはまります。

どちらのモジュールにも当てはまるようなテストを行う場合、これらの両方に依存したArchUnitのテスト用モジュール作成を検討してください。

### テスト実行にかかる時間について

対象となるクラスの増加などにより、テスト実行に多くの時間を要する可能性があります。

許容できない時間を要する場合は、ArchUnitのテスト用モジュール作成をするか、テスト実行時に対象から除外することを検討してください。

## 例外登録ルール

### アーキテクチャ違反除外方法

アーキテクチャ違反となっている箇所をテスト対象から外すには、大きく分けて以下の2つの方法があります。

- 除外設定ファイルに記載し、すべてのアーキテクチャテストから除外する。
- テストコードに除外対象を記載する。

後者はテスト対象によって記載が異なるため、注意してください。

### 除外設定ファイルに記載し、すべてのアーキテクチャテストから除外する

アーキテクチャテストを行うモジュールの `src/test/resources` 直下に `archunit_ignore_patterns.txt` を作成し、正規表現にて除外する対象を記載します。

```
# 1234
.*some\.pkg\.LegacyService.*
```

`#` をつけることでコメントを記載できるため、次のようにしておくと、後で経緯を追跡できます。

- 課題管理システムの課題管理番号をコメントに記載する
- バージョン管理システムのコミットコメントに記載する

#### 注意事項

この方法で除外したものは、全てのアーキテクチャテストの対象外になります。

既存のコードがある状態でArchUnitの導入を行った場合など、既存のコードをアーキテクチャテストの対象にしたくないものについて除外設定を行うようにしてください。

### 除外対象クラスの設定（テストコードに除外対象を記載）

テスト対象がクラス（レイヤーも含む）の場合、以下のように `and()`（または元々 `that()` がなければ `that()`）の引数に `DescribedPredicate.not(JavaClass.Predicates.equivalentTo(除外対象クラス))` を使用して除外設定を行う。

``` java
@ArchTest
public static final ArchRule ActionクラスはBatchActionを継承していること =
        ArchRuleDefinition.classes().that().haveSimpleNameEndingWith("Action")
        .and(DescribedPredicate.not(JavaClass.Predicates.belongToAnyOf(
                PromanExampleAction.class       // #12345
                , PromanServiceAction.class)))  // #12346
        .should().beAssignableTo(BatchAction.class);
```

テスト対象がクラス内に含まれるもの（フィールドやメソッドなど）の場合、 `areNotDeclaredIn()` を使用して除外設定をおこなう。

``` java
@ArchTest
public static final ArchRule DaoContextを引数にとるメソッドはパッケージプライベートであること =
        ArchRuleDefinition.methods().that().haveRawParameterTypes(DaoContext.class)
            .and().areNotDeclaredIn(PromanExamAction.class)  // #1234
            .should().bePackagePrivate();
```

除外設定をする場合は次のようにしておくと、後で経緯を追跡できます。

- 課題管理システムの課題管理番号をコメントに記載する
- バージョン管理システムのコミットコメントに記載する

### 除外対象パッケージ設定（テストコードに除外対象を記載）

テスト対象がクラスの場合、以下のようにして特定のパッケージを除外できます。
以下の例では `common` を含むパッケージを除外しています。

```java
@ArchTest
public  static  final ArchRule 基盤以外のパッケージでNoDataExceptionを使用しているクラスがないこと =
        ArchRuleDefinition.noClasses()
        .that().resideOutsideOfPackage("..common..") // #1234
        .should().dependOnClassesThat().areAssignableTo(NoDataException.class);
```

ただし、パッケージは特定の文字列にて対象を決定することになるため、あらかじめパッケージ構成について検討しておく必要があります。

### カスタムルールによる除外設定（テストコードに除外対象を記載する）

カスタムルールを実装することで、より細かな除外設定を行うことができます。
内容については [ArchUnit User Guide](https://www.archunit.org/userguide/html/000_Index.html#_creating_custom_rules) を参照してください。