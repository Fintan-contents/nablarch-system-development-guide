package com.nablarch.example.proman.web.common.authentication.encrypt;

import nablarch.core.util.Base64Util;

import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;
import java.nio.charset.Charset;
import java.security.NoSuchAlgorithmException;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.KeySpec;

/**
 * Class for password encryption using PBKDF2.
 * <p/>
 * Byte strings used for salt are generated by connecting a fixed string set with {@link #fixedSalt} to a character string specified as {@code saltSeed}
 * using {@link #encrypt(String, String)} and encoded using UTF-8.
 * <p/>
 * The password is encrypted by stretching the number of times specified in {@link #iterationCount}.
 * The encrypted password is the length (bit count) set in {@link #keyLength}.
 *
 * @author Nabu Rakutaro
 */
public class PBKDF2PasswordEncryptor implements PasswordEncryptor {

    /**
     * Name of encryption algorithm
     */
    private static final String CRYPT_ALGORITHM = "PBKDF2WithHmacSha1";

    /**
     * Number of stretches for password encryption
     * <p/>
     * The default is 3966.
     */
    private int iterationCount = 3966;

    /**
     * Length (bit count) of encrypted password
     * <p/>
     * The default is 256.
     */
    private int keyLength = 256;

    /**
     * Fixed string used as salt throughout system
     * <p/>
     * Needs to be set, as no default value is set. The actual salt is a byte string consisting of this character string with the user ID attached.
     */
    private String fixedSalt;

    /**
     * Thread safe {@link SecretKeyFactory}.
     * <p/>
     * {@link SecretKeyFactory} is thread local as it is expected to be used as a singleton instance.
     */
    private static final ThreadLocal<SecretKeyFactory> FACTORY = ThreadLocal.withInitial(() -> {
        try {
            return SecretKeyFactory.getInstance(CRYPT_ALGORITHM);
        } catch (NoSuchAlgorithmException e) {
            // This exception will not occur when using a JRE where PBKDF2WithHmacSha1 is provided, such as Oracle JRE, as an algorithm exists.
            throw new IllegalStateException("Initialization Failed. Can't get instance of SecretKeyFactory. "
                    + "Algorithm name is '" + CRYPT_ALGORITHM + "'.", e);
        }
    });

    /**
     * PBKDF2 encrypts the password and returns with  base-64 encoding.
     * <p/>
     * If {@code saltSeed} or {@code password} is a null character string, a null character string is returned.
     * {@link IllegalArgumentException} occurs if either is {@code null}.
     *
     * @param saltSeed: Character string used to generate salt to be used for password encryption
     * @param password: Unencrypted password
     * @return: Character string with base-64 encoding for encrypted password
     * @throws IllegalStateException: When {@link #fixedSalt} is not set
     * @see Base64Util#encode(byte[])
     */
    @Override
    public String encrypt(String saltSeed, String password) {
        verifyParameter(saltSeed, password);

        if (saltSeed.isEmpty() || password.isEmpty()) {
            return "";
        }

        KeySpec spec = new PBEKeySpec(password.toCharArray(), getSalt(saltSeed), getIterationCount(), getKeyLength());
        byte[] encryptPassword;
        try {
            do {
                encryptPassword = FACTORY.get()
                                         .generateSecret(spec)
                                         .getEncoded();
            } while (!isSuccessEncryption(encryptPassword));
        } catch (InvalidKeySpecException e) {
            // This exception occurs for null passwords, but does not occur in this case as a prior check is performed.
            throw new IllegalStateException(e);
        }
        return Base64Util.encode(encryptPassword);
    }

    /**
     * Verifies whether the information required for encryption is correct.
     * <p>
     * If it is incorrect, {@link IllegalArgumentException} is sent.
     *
     * @param saltSeed: Character string used to generate salt to be used for password encryption
     * @param password: Unencrypted password
     */
    private void verifyParameter(String saltSeed, String password) {
        if (saltSeed == null || password == null) {
            throw new IllegalArgumentException("saltSeed and password must not be null.");
        }
    }

    /**
     * Returns a value indicating whether the encryption process was successful.
     * <p/>
     * Encryption is judged to have failed if every character of the encrypted password is "0".
     *
     * @param bytes: Encrypted password
     * @return: {@code true} if encryption is successful
     */
    private static boolean isSuccessEncryption(byte[] bytes) {
        for (byte b : bytes) {
            if (b != 0) {
                return true;
            }
        }
        return false;
    }

    /**
     * The returned value is a byte string consisting of {@link #fixedSalt} and {@code saltSeed} joined together with UTF-8 encoding.
     *
     * @param saltSeed: Character string used to generate salt
     * @return: Byte string consisting of {@link #fixedSalt} and {@code saltSeed} joined together with UTF-8 encoding.
     * @throws IllegalStateException: When {@link #fixedSalt} is not set
     */
    private byte[] getSalt(String saltSeed) throws IllegalStateException {
        String fixed = getFixedSalt();
        if (fixed == null) {
            throw new IllegalStateException("Fixed salt string is not set.");
        }
        return (fixed + saltSeed).getBytes(Charset.forName("UTF-8"));
    }

    /**
     * Returns the number of stretches for password encryption.
     *
     * @return: Number of stretches
     */
    public int getIterationCount() {
        return iterationCount;
    }

    /**
     * Sets the number of stretches for password encryption. A positive value must be set.
     *
     * @param iterationCount: Number of stretches (positive value)
     */
    public void setIterationCount(int iterationCount) {
        this.iterationCount = iterationCount;
    }

    /**
     * Returns length of encrypted password.
     *
     * @return: Length of encrypted password
     */
    public int getKeyLength() {
        return keyLength;
    }

    /**
     * Set length of encrypted password. A positive value must be set.
     *
     * @param keyLength: Length of encrypted password
     */
    public void setKeyLength(int keyLength) {
        this.keyLength = keyLength;
    }

    /**
     * Returns fixed string used as salt throughout system.
     *
     * @return: Fixed string used as salt throughout system
     */
    public String getFixedSalt() {
        return fixedSalt;
    }

    /**
     * Set fixed string used as salt throughout system.
     *
     * @param fixedSalt: Fixed string used as salt throughout system
     */
    public void setFixedSalt(String fixedSalt) {
        this.fixedSalt = fixedSalt;
    }
}
